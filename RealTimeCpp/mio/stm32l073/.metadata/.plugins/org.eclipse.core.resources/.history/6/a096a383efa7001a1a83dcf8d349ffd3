/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <cstdint>
#include "main.h"

//class led {
//public:
//	// Use convenient class-specific typedefs.
//	typedef std::uint32_t port_type;
//	typedef std::uint8_t bval_type;
//
//	// The led class constructor.
//	led(const port_type p, const bval_type b) :
//			port(p), bval(b) {
//		// Set the port pin mode to output
////		const port_type pmode = port;
////		*reinterpret_cast<volatile port_type*>(pmode) &= static_cast<bval_type>(~(0x03U << (bval*2)));
////		*reinterpret_cast<volatile port_type*>(pmode) |= static_cast<bval_type>( (0x01U << (bval*2)));
//
//		// Set the port pin type to push-pull
//		const port_type potype = port + 0x04UL;
//		*reinterpret_cast<volatile port_type*>(potype) &=
//				static_cast<bval_type>(~bval);
//
//		// Set the port pin value to low
//		const port_type pval = port + 0x14UL;
//		*reinterpret_cast<volatile port_type*>(pval) &=
//				static_cast<bval_type>(~bval);
//
//	}
//
//	void toggle() const {
//		// Toggle the LED via direct memory access.
//		const port_type pval = port + 0x14UL;
//		*reinterpret_cast<volatile bval_type*>(pval) ^= bval;
//	}
//
//	void on() const {
//		// Set the port pin value to high
//		const port_type pval = port + 0x14UL;
//		*reinterpret_cast<volatile bval_type*>(pval) |= bval;
//	}
//
//private:
//	// Private member variables of the class.
//	const port_type port;
//	const bval_type bval;
//};
class led {
public:
	// Use convenient class-specific typedefs.
	typedef std::uint8_t pin_number_type;

	// The led class constructor.
	led(const port_type p, const bval_type b) :
			port(p), bval(b) {
		// Set the port pin mode to output
//		const port_type pmode = port;
//		*reinterpret_cast<volatile port_type*>(pmode) &= static_cast<bval_type>(~(0x03U << (bval*2)));
//		*reinterpret_cast<volatile port_type*>(pmode) |= static_cast<bval_type>( (0x01U << (bval*2)));

		// Set the port pin type to push-pull
		const port_type potype = port + 0x04UL;
		*reinterpret_cast<volatile port_type*>(potype) &=
				static_cast<bval_type>(~bval);

		// Set the port pin value to low
		const port_type pval = port + 0x14UL;
		*reinterpret_cast<volatile port_type*>(pval) &=
				static_cast<bval_type>(~bval);

	}

	void toggle() const {
		// Toggle the LED via direct memory access.
		const port_type pval = port + 0x14UL;
		*reinterpret_cast<volatile bval_type*>(pval) ^= bval;
	}

	void on() const {
		// Set the port pin value to high
		const port_type pval = port + 0x14UL;
		*reinterpret_cast<volatile bval_type*>(pval) |= bval;
	}

private:
	// Private member variables of the class.
	GPIO_TypeDef * const gpio_port;
	const pin_number_type pin_number;
};

namespace {
// Create led_a5 on porta.5.
const led led_a5 {
GPIOA_BASE, (0x1UL << 5U) };
}

int main(void) {
	/*	User LD2: the green LED is a user LED connected to PA5
	 */
	RCC->IOPENR |= RCC_IOPENR_IOPAEN;
	GPIOA->MODER &= ~(GPIO_MODER_MODE5_1); //~(GPIO_MODER_MODE5_0 | GPIO_MODER_MODE5_1);
	led_a5.on();
	while (1) {
		for (volatile std::uint32_t i = 0; i < 20000; i++) {
		}
		led_a5.toggle();
	}
}

//int main(void) {
//	/*	User LD2: the green LED is a user LED connected to PA5
//	 */
//	RCC->IOPENR |= RCC_IOPENR_IOPAEN;
//	GPIOA->MODER &= ~(GPIO_MODER_MODE5_1); //~(GPIO_MODER_MODE5_0 | GPIO_MODER_MODE5_1);
//	GPIOA->MODER |= GPIO_MODER_MODE5_0;
//	GPIOA->OTYPER &= ~(GPIO_OTYPER_OT_5);
//	GPIOA->ODR |= GPIO_ODR_OD5;
//	for (;;)
//		;
//}
